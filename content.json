{"meta":{"title":"Hexo","subtitle":"","description":"","author":"pandc","url":"http://example.com","root":"/"},"pages":[{"title":"文章归档","date":"2022-08-22T17:40:18.309Z","updated":"2022-08-22T17:38:39.629Z","comments":true,"path":"archive.html","permalink":"http://example.com/archive.html","excerpt":"","text":"比如"}],"posts":[{"title":"first blog","slug":"first-blog","date":"2022-08-22T16:06:21.000Z","updated":"2022-08-22T16:06:21.332Z","comments":true,"path":"2022/08/23/first-blog/","link":"","permalink":"http://example.com/2022/08/23/first-blog/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-22T15:45:31.882Z","updated":"2022-08-22T15:45:31.882Z","comments":true,"path":"2022/08/22/hello-world/","link":"","permalink":"http://example.com/2022/08/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"leetcode每日一题","slug":"yuque/leetcode每日一题","date":"2022-07-25T00:08:34.000Z","updated":"2022-08-23T00:17:25.658Z","comments":true,"path":"2022/07/25/yuque/leetcode每日一题/","link":"","permalink":"http://example.com/2022/07/25/yuque/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"919. 完全二叉树插入器数据结构二叉树","categories":[],"tags":[]},{"title":"leetcode 刷题","slug":"yuque/leetcode 刷题","date":"2022-07-10T14:35:19.000Z","updated":"2022-08-23T00:17:25.658Z","comments":true,"path":"2022/07/10/yuque/leetcode 刷题/","link":"","permalink":"http://example.com/2022/07/10/yuque/leetcode%20%E5%88%B7%E9%A2%98/","excerpt":"","text":"741 摘樱桃动态规划困难https://leetcode.cn/problems/cherry-pickup/","categories":[],"tags":[]},{"title":"linux","slug":"yuque/linux","date":"2021-10-06T08:37:09.000Z","updated":"2022-08-23T00:17:25.658Z","comments":true,"path":"2021/10/06/yuque/linux/","link":"","permalink":"http://example.com/2021/10/06/yuque/linux/","excerpt":"","text":"使用 acterminal 来进行 作业的使用","categories":[],"tags":[]},{"title":"算法基础课","slug":"yuque/算法基础课","date":"2021-09-25T10:01:27.000Z","updated":"2022-08-23T00:17:25.658Z","comments":true,"path":"2021/09/25/yuque/算法基础课/","link":"","permalink":"http://example.com/2021/09/25/yuque/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/","excerpt":"","text":"快排 快速排序 第 k 个数字 归并排序 归并排序 逆序对的数量 二分数字的范围数的三次方高精度前缀与差分双指针算法位运算离散化区间合并","categories":[],"tags":[]},{"title":"暑期算法每日一题","slug":"yuque/暑期算法每日一题","date":"2021-07-17T02:05:32.000Z","updated":"2022-08-23T00:17:25.658Z","comments":true,"path":"2021/07/17/yuque/暑期算法每日一题/","link":"","permalink":"http://example.com/2021/07/17/yuque/%E6%9A%91%E6%9C%9F%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"https://www.acwing.com/problem/content/3766/ 题干给定一个 n×m 的整数矩阵，其中第 i 行第 j 列的元素为 aij。你可以进行任意多次如下操作：选择矩阵中的两个相邻元素，将它们均乘以 −1。同一个元素可以被选中多次。你需要通过上述操作，使得矩阵中所有元素的和尽可能大。计算并输出这个和的最大可能值。 输入格式第一行包含整数 T，表示共有 T 组测试数据。每组数据第一行包含两个整数 n,m。接下来 n 行，每行包含 m 个整数，表示整个矩阵，其中第 i 行第 j 列的数为 aij。 输出格式每组数据输出一行结果，表示矩阵的所有元素的最大可能和。 数据范围1≤T≤100,2≤n,m≤10,−100≤aij≤100 输入样例：22 2-1 11 13 40 -1 -2 -3-1 -2 -3 -4-2 -3 -4 -5 输出样例：2 30 解题思路","categories":[],"tags":[]},{"title":"算法笔记 动态规划DP","slug":"yuque/算法笔记 动态规划DP","date":"2021-03-17T13:39:52.000Z","updated":"2022-08-22T16:44:19.461Z","comments":true,"path":"2021/03/17/yuque/算法笔记 动态规划DP/","link":"","permalink":"http://example.com/2021/03/17/yuque/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP/","excerpt":"","text":"背包问题","categories":[],"tags":[]},{"title":"LeetCode 132. Palindrome Partitioning II - AcWing","slug":"yuque/LeetCode 132. Palindrome Partitioning II - AcWing","date":"2021-03-08T03:21:12.000Z","updated":"2022-08-22T16:44:19.461Z","comments":true,"path":"2021/03/08/yuque/LeetCode 132. Palindrome Partitioning II - AcWing/","link":"","permalink":"http://example.com/2021/03/08/yuque/LeetCode%20132.%20Palindrome%20Partitioning%20II%20-%20AcWing/","excerpt":"","text":"LeetCode 132. Palindrome Partitioning II 原题链接 困难作者： yxc , 2018-05-30 09:41:57 , 阅读 1976 题目描述给定一个字符串 s，请将它划分成若干部分，使得每一部分都是回文串。求最少需要切几刀。 样例123输入：&quot;aab&quot;输出：1解释：可以划分成：[&quot;aa&quot;,&quot;b&quot;]，所以只用切1刀。 算法(动态规划) O(n2)一共进行两次动态规划。 第一次动规：计算出每个子串是否是回文串。状态表示：st[i][j] 表示 s[i…j] 是否是回文串;转移方程：s[i…j] 是回文串当且仅当 s[i]等于 s[j] 并且 s[i+1…j−1] 是回文串；边界情况：如果 s[i…j]的长度小于等于 2，则 st[i][j]=(s[i]=&#x3D;s[j]); 在第一次动规的基础上，我们进行第二次动规。状态表示：f[i] 表示把前 i 个字符划分成回文串，最少划分成几部分；状态转移：枚举最后一段回文串的起点 j，然后利用 st[j][i] 可知 s[j…i] 是否是回文串，如果是回文串，则 f[i] 可以从 f[j−1]+1 转移；边界情况：0 个字符可以划分成 0 部分，所以 f[0]=0。 题目让我们求最少切几刀，所以答案是 f[n]−1。 时间复杂度分析：两次动规都是两重循环，所以时间复杂度是 O(n2)。 C++ 代码123456789101112131415161718192021222324class Solution &#123;public: int minCut(string s) &#123; int n = s.size(); vector&lt;int&gt;f(n + 1); vector&lt;vector&lt;bool&gt;&gt; st(n, vector&lt;bool&gt;(n, false)); for (int i = 0; i &lt; n; i ++ ) for (int j = i; j &gt;= 0; j -- ) if (i - j &lt;= 1) st[j][i] = s[j] == s[i]; else st[j][i] = s[j] == s[i] &amp;&amp; st[j + 1][i - 1]; f[0] = 0; for (int i = 1; i &lt;= n; i ++ ) &#123; f[i] = INT_MAX; for (int j = 0; j &lt; i; j ++ ) if (st[j][i - 1]) f[i] = min(f[i], f[j] + 1); &#125; return max(0, f[n] - 1); &#125;&#125;; https://www.acwing.com/solution/content/227/","categories":[],"tags":[]}],"categories":[],"tags":[]}